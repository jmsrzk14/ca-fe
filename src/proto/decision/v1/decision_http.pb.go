// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// - protoc-gen-go-http v2.9.2
// - protoc             v5.29.3
// source: decision/v1/decision.proto

package v1

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

const OperationCommitteeServiceCreateCommitteeSession = "/api.decision.v1.CommitteeService/CreateCommitteeSession"
const OperationCommitteeServiceFinalizeCommitteeDecision = "/api.decision.v1.CommitteeService/FinalizeCommitteeDecision"
const OperationCommitteeServiceGetCommitteeSession = "/api.decision.v1.CommitteeService/GetCommitteeSession"
const OperationCommitteeServiceListCommitteeSessionsByApplication = "/api.decision.v1.CommitteeService/ListCommitteeSessionsByApplication"
const OperationCommitteeServiceSubmitCommitteeVote = "/api.decision.v1.CommitteeService/SubmitCommitteeVote"

type CommitteeServiceHTTPServer interface {
	CreateCommitteeSession(context.Context, *CreateCommitteeSessionRequest) (*CommitteeSession, error)
	FinalizeCommitteeDecision(context.Context, *FinalizeCommitteeDecisionRequest) (*CommitteeDecision, error)
	GetCommitteeSession(context.Context, *GetCommitteeSessionRequest) (*CommitteeSession, error)
	ListCommitteeSessionsByApplication(context.Context, *ListCommitteeSessionsByApplicationRequest) (*ListCommitteeSessionsResponse, error)
	SubmitCommitteeVote(context.Context, *SubmitCommitteeVoteRequest) (*CommitteeVote, error)
}

func RegisterCommitteeServiceHTTPServer(s *http.Server, srv CommitteeServiceHTTPServer) {
	r := s.Route("/")
	r.POST("/v1/committee/sessions", _CommitteeService_CreateCommitteeSession0_HTTP_Handler(srv))
	r.GET("/v1/committee/sessions/{id}", _CommitteeService_GetCommitteeSession0_HTTP_Handler(srv))
	r.POST("/v1/committee/sessions/{committee_session_id}/votes", _CommitteeService_SubmitCommitteeVote0_HTTP_Handler(srv))
	r.POST("/v1/committee/sessions/{committee_session_id}/finalize", _CommitteeService_FinalizeCommitteeDecision0_HTTP_Handler(srv))
	r.GET("/v1/applications/{application_id}/committee-sessions", _CommitteeService_ListCommitteeSessionsByApplication0_HTTP_Handler(srv))
}

func _CommitteeService_CreateCommitteeSession0_HTTP_Handler(srv CommitteeServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in CreateCommitteeSessionRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationCommitteeServiceCreateCommitteeSession)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.CreateCommitteeSession(ctx, req.(*CreateCommitteeSessionRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*CommitteeSession)
		return ctx.Result(200, reply)
	}
}

func _CommitteeService_GetCommitteeSession0_HTTP_Handler(srv CommitteeServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetCommitteeSessionRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationCommitteeServiceGetCommitteeSession)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetCommitteeSession(ctx, req.(*GetCommitteeSessionRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*CommitteeSession)
		return ctx.Result(200, reply)
	}
}

func _CommitteeService_SubmitCommitteeVote0_HTTP_Handler(srv CommitteeServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in SubmitCommitteeVoteRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationCommitteeServiceSubmitCommitteeVote)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.SubmitCommitteeVote(ctx, req.(*SubmitCommitteeVoteRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*CommitteeVote)
		return ctx.Result(200, reply)
	}
}

func _CommitteeService_FinalizeCommitteeDecision0_HTTP_Handler(srv CommitteeServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in FinalizeCommitteeDecisionRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationCommitteeServiceFinalizeCommitteeDecision)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.FinalizeCommitteeDecision(ctx, req.(*FinalizeCommitteeDecisionRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*CommitteeDecision)
		return ctx.Result(200, reply)
	}
}

func _CommitteeService_ListCommitteeSessionsByApplication0_HTTP_Handler(srv CommitteeServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ListCommitteeSessionsByApplicationRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationCommitteeServiceListCommitteeSessionsByApplication)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ListCommitteeSessionsByApplication(ctx, req.(*ListCommitteeSessionsByApplicationRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ListCommitteeSessionsResponse)
		return ctx.Result(200, reply)
	}
}

type CommitteeServiceHTTPClient interface {
	CreateCommitteeSession(ctx context.Context, req *CreateCommitteeSessionRequest, opts ...http.CallOption) (rsp *CommitteeSession, err error)
	FinalizeCommitteeDecision(ctx context.Context, req *FinalizeCommitteeDecisionRequest, opts ...http.CallOption) (rsp *CommitteeDecision, err error)
	GetCommitteeSession(ctx context.Context, req *GetCommitteeSessionRequest, opts ...http.CallOption) (rsp *CommitteeSession, err error)
	ListCommitteeSessionsByApplication(ctx context.Context, req *ListCommitteeSessionsByApplicationRequest, opts ...http.CallOption) (rsp *ListCommitteeSessionsResponse, err error)
	SubmitCommitteeVote(ctx context.Context, req *SubmitCommitteeVoteRequest, opts ...http.CallOption) (rsp *CommitteeVote, err error)
}

type CommitteeServiceHTTPClientImpl struct {
	cc *http.Client
}

func NewCommitteeServiceHTTPClient(client *http.Client) CommitteeServiceHTTPClient {
	return &CommitteeServiceHTTPClientImpl{client}
}

func (c *CommitteeServiceHTTPClientImpl) CreateCommitteeSession(ctx context.Context, in *CreateCommitteeSessionRequest, opts ...http.CallOption) (*CommitteeSession, error) {
	var out CommitteeSession
	pattern := "/v1/committee/sessions"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationCommitteeServiceCreateCommitteeSession))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *CommitteeServiceHTTPClientImpl) FinalizeCommitteeDecision(ctx context.Context, in *FinalizeCommitteeDecisionRequest, opts ...http.CallOption) (*CommitteeDecision, error) {
	var out CommitteeDecision
	pattern := "/v1/committee/sessions/{committee_session_id}/finalize"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationCommitteeServiceFinalizeCommitteeDecision))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *CommitteeServiceHTTPClientImpl) GetCommitteeSession(ctx context.Context, in *GetCommitteeSessionRequest, opts ...http.CallOption) (*CommitteeSession, error) {
	var out CommitteeSession
	pattern := "/v1/committee/sessions/{id}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationCommitteeServiceGetCommitteeSession))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *CommitteeServiceHTTPClientImpl) ListCommitteeSessionsByApplication(ctx context.Context, in *ListCommitteeSessionsByApplicationRequest, opts ...http.CallOption) (*ListCommitteeSessionsResponse, error) {
	var out ListCommitteeSessionsResponse
	pattern := "/v1/applications/{application_id}/committee-sessions"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationCommitteeServiceListCommitteeSessionsByApplication))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *CommitteeServiceHTTPClientImpl) SubmitCommitteeVote(ctx context.Context, in *SubmitCommitteeVoteRequest, opts ...http.CallOption) (*CommitteeVote, error) {
	var out CommitteeVote
	pattern := "/v1/committee/sessions/{committee_session_id}/votes"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationCommitteeServiceSubmitCommitteeVote))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

const OperationDecisionServiceAddDecisionCondition = "/api.decision.v1.DecisionService/AddDecisionCondition"
const OperationDecisionServiceGetApplicationDecision = "/api.decision.v1.DecisionService/GetApplicationDecision"
const OperationDecisionServiceListDecisionConditions = "/api.decision.v1.DecisionService/ListDecisionConditions"
const OperationDecisionServiceRecordFinalDecision = "/api.decision.v1.DecisionService/RecordFinalDecision"

type DecisionServiceHTTPServer interface {
	AddDecisionCondition(context.Context, *AddDecisionConditionRequest) (*DecisionCondition, error)
	GetApplicationDecision(context.Context, *GetApplicationDecisionRequest) (*ApplicationDecision, error)
	ListDecisionConditions(context.Context, *ListDecisionConditionsRequest) (*ListDecisionConditionsResponse, error)
	RecordFinalDecision(context.Context, *RecordFinalDecisionRequest) (*ApplicationDecision, error)
}

func RegisterDecisionServiceHTTPServer(s *http.Server, srv DecisionServiceHTTPServer) {
	r := s.Route("/")
	r.POST("/v1/applications/{application_id}/final-decision", _DecisionService_RecordFinalDecision0_HTTP_Handler(srv))
	r.GET("/v1/applications/{application_id}/decision", _DecisionService_GetApplicationDecision0_HTTP_Handler(srv))
	r.POST("/v1/applications/{application_id}/decision-conditions", _DecisionService_AddDecisionCondition0_HTTP_Handler(srv))
	r.GET("/v1/applications/{application_id}/decision-conditions", _DecisionService_ListDecisionConditions0_HTTP_Handler(srv))
}

func _DecisionService_RecordFinalDecision0_HTTP_Handler(srv DecisionServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in RecordFinalDecisionRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationDecisionServiceRecordFinalDecision)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.RecordFinalDecision(ctx, req.(*RecordFinalDecisionRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ApplicationDecision)
		return ctx.Result(200, reply)
	}
}

func _DecisionService_GetApplicationDecision0_HTTP_Handler(srv DecisionServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetApplicationDecisionRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationDecisionServiceGetApplicationDecision)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetApplicationDecision(ctx, req.(*GetApplicationDecisionRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ApplicationDecision)
		return ctx.Result(200, reply)
	}
}

func _DecisionService_AddDecisionCondition0_HTTP_Handler(srv DecisionServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in AddDecisionConditionRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationDecisionServiceAddDecisionCondition)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.AddDecisionCondition(ctx, req.(*AddDecisionConditionRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*DecisionCondition)
		return ctx.Result(200, reply)
	}
}

func _DecisionService_ListDecisionConditions0_HTTP_Handler(srv DecisionServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ListDecisionConditionsRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationDecisionServiceListDecisionConditions)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ListDecisionConditions(ctx, req.(*ListDecisionConditionsRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ListDecisionConditionsResponse)
		return ctx.Result(200, reply)
	}
}

type DecisionServiceHTTPClient interface {
	AddDecisionCondition(ctx context.Context, req *AddDecisionConditionRequest, opts ...http.CallOption) (rsp *DecisionCondition, err error)
	GetApplicationDecision(ctx context.Context, req *GetApplicationDecisionRequest, opts ...http.CallOption) (rsp *ApplicationDecision, err error)
	ListDecisionConditions(ctx context.Context, req *ListDecisionConditionsRequest, opts ...http.CallOption) (rsp *ListDecisionConditionsResponse, err error)
	RecordFinalDecision(ctx context.Context, req *RecordFinalDecisionRequest, opts ...http.CallOption) (rsp *ApplicationDecision, err error)
}

type DecisionServiceHTTPClientImpl struct {
	cc *http.Client
}

func NewDecisionServiceHTTPClient(client *http.Client) DecisionServiceHTTPClient {
	return &DecisionServiceHTTPClientImpl{client}
}

func (c *DecisionServiceHTTPClientImpl) AddDecisionCondition(ctx context.Context, in *AddDecisionConditionRequest, opts ...http.CallOption) (*DecisionCondition, error) {
	var out DecisionCondition
	pattern := "/v1/applications/{application_id}/decision-conditions"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationDecisionServiceAddDecisionCondition))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *DecisionServiceHTTPClientImpl) GetApplicationDecision(ctx context.Context, in *GetApplicationDecisionRequest, opts ...http.CallOption) (*ApplicationDecision, error) {
	var out ApplicationDecision
	pattern := "/v1/applications/{application_id}/decision"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationDecisionServiceGetApplicationDecision))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *DecisionServiceHTTPClientImpl) ListDecisionConditions(ctx context.Context, in *ListDecisionConditionsRequest, opts ...http.CallOption) (*ListDecisionConditionsResponse, error) {
	var out ListDecisionConditionsResponse
	pattern := "/v1/applications/{application_id}/decision-conditions"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationDecisionServiceListDecisionConditions))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *DecisionServiceHTTPClientImpl) RecordFinalDecision(ctx context.Context, in *RecordFinalDecisionRequest, opts ...http.CallOption) (*ApplicationDecision, error) {
	var out ApplicationDecision
	pattern := "/v1/applications/{application_id}/final-decision"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationDecisionServiceRecordFinalDecision))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}
